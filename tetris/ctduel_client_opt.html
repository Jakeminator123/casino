<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Casino Tetris Duel — OPT</title>
<style>
  :root { --bg:#0b0f12; --panel:#121a20; --muted:#95a3ad; --accent:#39ff14; --gold:#ffd166; }
  body { margin:0; background: radial-gradient(circle at 70% 10%, #13202a, #06090c); color:#e6f2f8; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto; }
  .wrap { display:grid; grid-template-columns: 320px 1fr; gap:16px; padding:16px; max-width:1200px; margin:0 auto; }
  .card { background:linear-gradient(180deg, #121a20, #0b1014); border:1px solid rgba(255,255,255,0.08); border-radius:16px; padding:14px; box-shadow: 0 18px 40px rgba(0,0,0,.35); }
  h2,h3 { margin:8px 0 10px; }
  label { display:block; font-size:13px; color:var(--muted); margin-top:6px; }
  input { width:100%; padding:8px; border-radius:10px; border:1px solid rgba(255,255,255,.15); background:#091116; color:#e6f2f8; }
  .btn { display:inline-flex; align-items:center; gap:8px; border:1px solid rgba(255,255,255,.15); padding:10px 12px; border-radius:12px; cursor:pointer; background:#0e171d; color:#e6f2f8; }
  .btn:hover { border-color: rgba(57,255,20,.6); box-shadow:0 0 0 2px rgba(57,255,20,.12) inset; }
  .btn.primary { background: linear-gradient(90deg, #0f2, #0b3); color:#021; font-weight:700; }
  .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
  canvas { background: radial-gradient(circle at 50% 10%, rgba(18,54,29,0.75), rgba(6,14,10,0.95)); border-radius:16px; border:1px solid rgba(255,255,255,.08); }
  .pill { display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:#0b1418; }
  .muted { color:var(--muted); }
  .hud { display:flex; gap:12px; margin-top:8px; flex-wrap:wrap; }
  .big { font-size:24px; font-weight:800; color:var(--gold); }
  .timer { font-variant-numeric: tabular-nums; font-weight:700; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h2>Casino Tetris Duel — OPT</h2>
      <label>Room <input id="room" value="t1"></label>
      <label>Namn <input id="name" value="Spelare"></label>
      <label>Grundinsats / spelare <input id="ante" type="number" value="10" min="1"></label>
      <label>Seed (valfritt) <input id="seed" value="42"></label>
      <label>Antal pjäser <input id="pieces" type="number" value="20" min="8"></label>
      <div class="row" style="margin-top:8px;">
        <button id="btnCreate" class="btn">Skapa rum</button>
        <button id="btnJoin" class="btn">Gå med</button>
        <button id="btnStart" class="btn primary">Starta</button>
      </div>
      <div id="lobbyInfo" class="muted" style="margin-top:8px;"></div>
      <hr style="border-color:rgba(255,255,255,.08)">
      <h3>Kontroller</h3>
      <div class="muted">←/→ flytta • ↑ rotera • <b>mellanslag</b> lås/placera</div>
      <div class="muted">Du har <b>20s timebank per pjäs</b>. Missar du – auto‑placering i mitten.</div>
      <div style="margin-top:10px;">Giltiga kolumner: <span id="validCols" class="muted">-</span></div>
      <div id="lastMsg" class="muted" style="margin-top:8px;"></div>
      <div id="srvMode" class="muted" style="margin-top:8px;"></div>
    </div>

    <div class="card">
      <div class="row">
        <div class="pill">Fas: <span id="phase">LOBBY</span></div>
        <div class="pill">Pott: <span id="pot">—</span></div>
        <div class="pill">Pjäs <span id="idx">0</span>/<span id="len">0</span> • <span id="curr">-</span> → <span id="next">-</span></div>
        <div class="pill">Tid kvar: <span id="timer" class="timer">—</span></div>
      </div>
      <div class="row" style="margin-top:12px;">
        <div>
          <div><b id="p1name">P1</b> — rader: <span id="p1lines">0</span> • tetris: <span id="p1tetris">0</span></div>
          <canvas id="c1" width="300" height="600"></canvas>
        </div>
        <div>
          <div><b id="p2name">P2</b> — rader: <span id="p2lines">0</span> • tetris: <span id="p2tetris">0</span></div>
          <canvas id="c2" width="300" height="600"></canvas>
        </div>
      </div>
      <div id="result" class="big" style="margin-top:10px;"></div>
    </div>
  </div>

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script>
  // Force pure WebSocket (no HTTP polling) for smoother UX
  const socket = io({ transports: ['websocket'], upgrade: false, timeout: 10000 });
  let myRole = null; // 'P1' or 'P2'
  const $ = id => document.getElementById(id);

  const SHAPES = {
    I:[[[0,1],[1,1],[2,1],[3,1]],[[2,0],[2,1],[2,2],[2,3]],[[0,2],[1,2],[2,2],[3,2]],[[1,0],[1,1],[1,2],[1,3]]],
    O:[[[1,0],[2,0],[1,1],[2,1]],[[1,0],[2,0],[1,1],[2,1]],[[1,0],[2,0],[1,1],[2,1]],[[1,0],[2,0],[1,1],[2,1]]],
    T:[[[1,0],[0,1],[1,1],[2,1]],[[1,0],[1,1],[2,1],[1,2]],[[0,1],[1,1],[2,1],[1,2]],[[1,0],[0,1],[1,1],[1,2]]],
    J:[[[0,0],[0,1],[1,1],[2,1]],[[1,0],[2,0],[1,1],[1,2]],[[0,1],[1,1],[2,1],[2,2]],[[1,0],[1,1],[0,2],[1,2]]],
    L:[[[2,0],[0,1],[1,1],[2,1]],[[1,0],[1,1],[1,2],[2,2]],[[0,1],[1,1],[2,1],[0,2]],[[0,0],[1,0],[1,1],[1,2]]],
    S:[[[1,0],[2,0],[0,1],[1,1]],[[1,0],[1,1],[2,1],[2,2]],[[1,1],[2,1],[0,2],[1,2]],[[0,0],[0,1],[1,1],[1,2]]],
    Z:[[[0,0],[1,0],[1,1],[2,1]],[[2,0],[1,1],[2,1],[1,2]],[[0,1],[1,1],[1,2],[2,2]],[[1,0],[0,1],[1,1],[0,2]]]
  };
  const COLORS = { I:'#00e5ff', O:'#ffd166', T:'#d67cff', J:'#6ec1ff', L:'#ff9f1c', S:'#7ae582', Z:'#ff4d6d' };
  const COLS=10, ROWS=20;
  let localRot = 0, localX = 3;

  $('btnCreate').onclick = () => {
    socket.emit('create_room', {
      room: $('room').value, name: $('name').value, ante: $('ante').value, seed: $('seed').value||42, pieces: $('pieces').value
    });
  };
  $('btnJoin').onclick = () => { socket.emit('join_room', { room: $('room').value, name: $('name').value }); };
  $('btnStart').onclick = () => socket.emit('start', {});

  document.addEventListener('keydown', (e) => {
    if (!current || phase!=='PLAYING') return;
    if (e.code==='ArrowLeft') { localX -= 1; requestValid(); }
    if (e.code==='ArrowRight'){ localX += 1; requestValid(); }
    if (e.code==='ArrowUp'){ localRot = (localRot+1)%4; requestValid(); }
    if (e.code==='Space'){ place(); }
  });

  function requestValid() { socket.emit('valid', { rot: localRot }); }
  function place() { socket.emit('place', { rot: localRot, x: localX }); }

  socket.on('joined', (d) => {
    myRole = d.as; $('lobbyInfo').textContent = `Du är ${d.as} i rum ${d.room}.`;
    $('srvMode').textContent = `Server async_mode: ${d.async_mode}`;
  });
  socket.on('place_result', (d) => { $('lastMsg').textContent = d.ok ? 'Drag skickat.' : ('Fel: ' + d.message); });

  let phase='LOBBY', current=null, nextP=null, len=0, idx=0, deadline=0, validCols=[];
  let grids = {P1:[], P2:[]}, names={P1:'P1',P2:'P2'}, lines={P1:0,P2:0}, tetris={P1:0,P2:0};
  const c1 = $('c1'), c2 = $('c2');
  const ctx1 = c1.getContext('2d'), ctx2 = c2.getContext('2d');

  function drawBoard(ctx, rows, previewPiece) {
    const CELL = 30;
    ctx.clearRect(0,0,c1.width,c1.height);
    for (let y=0;y<ROWS;y++){
      const row = rows[y] || '..........';
      for (let x=0;x<COLS;x++){
        const ch = row[x];
        if (ch && ch!=='.') drawCell(ctx,x,y,COLORS[ch], CELL);
        else drawGrid(ctx,x,y,CELL);
      }
    }
    if (previewPiece){
      ctx.globalAlpha = 0.25;
      for (const [x,y] of previewPiece) drawCell(ctx,x,y,'#39ff14',30);
      ctx.globalAlpha = 1.0;
    }
  }
  function drawGrid(ctx,x,y,CELL){ ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.strokeRect(x*CELL+4,y*CELL+4,CELL-8,CELL-8); }
  function drawCell(ctx,x,y,color,CELL){
    const px=x*CELL, py=y*CELL;
    ctx.fillStyle='#05110a'; ctx.fillRect(px+1,py+1,CELL-2,CELL-2);
    ctx.shadowColor=color; ctx.shadowBlur=8;
    ctx.strokeStyle=color; ctx.strokeRect(px+3,py+3,CELL-6,CELL-6);
    const g=ctx.createLinearGradient(px,py,px+CELL,py+CELL); g.addColorStop(0,color); g.addColorStop(1,'#ffffff22'); ctx.fillStyle=g;
    ctx.fillRect(px+4,py+4,CELL-8,CELL-8); ctx.shadowBlur=0;
  }
  function hardDropPreview(rows, pieceName, rot, xOffset){
    const cells = SHAPES[pieceName][rot%4];
    const minx = Math.min(...cells.map(c=>c[0])), maxx = Math.max(...cells.map(c=>c[0]));
    if (xOffset+minx<0) xOffset = -minx;
    if (xOffset+maxx>=COLS) xOffset = COLS-1-maxx;
    let y=0;
    while(true){
      let collided=false, out=false;
      for (const [cx,cy] of cells){
        const xx = xOffset+cx, yy = y+cy;
        if (yy>=ROWS){ out=true; break; }
        if (yy>=0 && rows[yy][xx]!=='.') { collided=true; break; }
      }
      if (collided || out){ y-=1; return cells.map(([cx,cy])=>[xOffset+cx,y+cy]); }
      y++;
    }
  }

  socket.on('state', (s) => {
    phase = s.phase;
    $('phase').textContent = s.phase;
    $('pot').textContent = s.pot;
    $('len').textContent = s.queue_len;
    $('idx').textContent = Math.min(s.piece_idx+1, s.queue_len);
    current = s.current_piece; nextP = s.next_piece;
    $('curr').textContent = current || '-'; $('next').textContent = nextP || '-';
    deadline = s.deadline_ts || 0;

    names.P1 = s.players.P1.name; names.P2 = s.players.P2.name;
    $('p1name').textContent = names.P1; $('p2name').textContent = names.P2;
    grids.P1 = s.players.P1.grid; grids.P2 = s.players.P2.grid;
    lines.P1 = s.players.P1.lines; lines.P2 = s.players.P2.lines;
    tetris.P1 = s.players.P1.tetris; tetris.P2 = s.players.P2.tetris;
    $('p1lines').textContent = lines.P1; $('p2lines').textContent = lines.P2;
    $('p1tetris').textContent = tetris.P1; $('p2tetris').textContent = tetris.P2;

    if (current){ localRot = 0; localX = 3; requestValid(); }
    $('result').textContent = '';
    if (s.result){
      const w = s.result.winner ? (s.result.winner===myRole?'DU VANN!':'Motståndaren vann') : 'Oavgjort';
      $('result').textContent = `${w}  (P1 ${s.result.payout.P1} — P2 ${s.result.payout.P2})`;
    }
    render();
  });

  function render(){
    let preview = null;
    if (phase==='PLAYING' && current){ preview = hardDropPreview(grids[myRole], current, localRot, localX); }
    drawBoard(c1.getContext('2d'), grids.P1, (myRole==='P1')?preview:null);
    drawBoard(c2.getContext('2d'), grids.P2, (myRole==='P2')?preview:null);
  }

  // Just UI countdown (no server tick from client)
  setInterval(()=>{
    if (deadline>0){
      const remain = Math.max(0, Math.floor(deadline - (Date.now()/1000)));
      $('timer').textContent = remain + 's';
    } else $('timer').textContent = '—';
  }, 250);
  </script>
</body>
</html>
